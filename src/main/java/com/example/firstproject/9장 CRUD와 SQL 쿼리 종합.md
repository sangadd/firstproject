## 9.1 JPA 로깅 설정하기 
서버에서 데이터의 생성, 조회, 수정, 삭제 등을 요청 -> JPA의 리파지터리가 DB에 해당 요청을 전달 -> 요청을 받은 DB는 자신의 언어, 즉 SQL로 쿼리를 작성해 테이블 속 
데이터를 관리 

**쿼리** : DB에 정보를 요청하는 구문, 데이터의 생성은 INSERT문, 조회는 SELECT문, 수정은 UPDATE문, 삭제는 DELETE문을 사용한다. 

**로깅** : 시스템이 작동할 때 당시의 상태와 작동 정보를 기록하는 것을 말한다. JPA의 로깅 설정은 application.properties 파일에서 함 

**로깅 7단계**
`TRACE(레벨1)` : DEBUG 레벨보다 더 상세한 정보 
`DEBUG(레벨2)` : 응용 프로그램을 디버깅하는 데 필요한 세부 정보 
`INFO(레벨3)` : 응용 프로그램의 순조로운 진행 정보 
`WHRN(레벨4)` : 잠재적으로 유해한 상황 정보 
`ERROR(레벨5)` : 응용 프로그램이 수행할 수 있는 정도의 오류 정보 
`FATAL(레벨6)` : 응용 프로그램이 중단될 만한 심각한 오류 정보 
`OFF(레벨7)` : 로깅 기능 해제

## 9.3 기본 SQL 쿼리 작성하기 
```
    create table article (
        id bigint generated by default as identity,
        content varchar(255),
        title varchar(255),
        primary key (id)
    )
```

인텔리제이 실행창으로 가서 CREATE를 검색해보면 위와 같은 create table문이 수행된 것을 볼 수 있는데, 
이 create table문은 테이블을 만드는 쿼리.

**근데 이 쿼리는 어떻게 동작하는걸까?**
Article 클래스를 보면 @Entity 어노테이션이 DB가 해당 객체를 인식하도록 붙인 것인데 해당 클래스로 테이블을 만들라는 뜻임 
즉 서버를 실행하면 새로운 Article 객체가 만들어지기 때문에 create table문도 자동으로 실행되는 것임 !!! 

`create table문 형식`
```
create table 테이블명 (
       속성명1 자료형, 
       속성명2 자료형, 
       속성명3 자료형, 
       primary key(기본키)
)
```
- 생성 테이블을 특정 값으로 명시하고 싶은 경우, 
  - 엔티티 클래스에 @Table 어노테이션을 사용하면 된다. 
  - 엔티티 클래스에 @Table(name = "ORDERS")를 선언하면 클래스명과 상관없이 ORDERS 라는 이름의 테이블이 생성된다.

------
1. insert문   
- 테이블에 데이터를 생성하는 쿼리  
- 한 번에 하나 또는 여러 데이터를 삽입할 수 있다.  

`형식`
```
insert 
info 
    테이블명 
    (속성명1, 속성명2, ...)
values 
    (값1, 값2, ...);
```
------

2. select 문
- 테이블에 데이터를 조회하는 쿼리
- where 절이 없으면 조건 없이 모든 데이터를 조회한다. 

`형식`
```
select 
    속성명1, 속성명2, ...
from 
    테이블명 
values 
    조건 
```
------

3. update 문 
- 테이블에 데이터를 수정하는 쿼리
- where 절이 없으면 조건 없이 모든 데이터를 수정한다. 

`형식`
```
update 
    테이블명 
set 
    속성명 = 변경할 값 
values 
    조건 
```
------

4. delete 문 
- 테이블에 데이터를 삭제하는 쿼리
- where 절이 없으면 조건 없이 모든 데이터를 삭제한다. 

`형식`
```
delete 
[from]   --> [] 이 안에 있는건 생략 가능 
    테이블명 
values 
    조건 
```